# -*- coding: utf-8 -*-
"""Data Scientistprediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UlVB3dvagwS7bublrWJUHYygVnrvWg8x

**predict 10 products to the retail shops for stocking for the next week. **
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df= pd.read_excel('/content/drive/MyDrive/sample_retail_data.xlsx')  #read/open file

df1= pd.read_excel('/content/drive/MyDrive/sample_retail_data.xlsx', sheet_name='Retailer_Master')  #see every sheet in file
df2= pd.read_excel('/content/drive/MyDrive/sample_retail_data.xlsx', sheet_name='Sales')
df3= pd.read_excel('/content/drive/MyDrive/sample_retail_data.xlsx', sheet_name='ProductMaster')

df1

df2



df = pd.merge(df1, df2, on='RetailerCode', how='inner')  #using inner join for merge sheets

df



df

df.shape

df2.shape

df_new = pd.merge(df, df3, on='ProductCode', how='inner')  #same as upper methed

df_new.head(5)

df_new.columns

df_new.info()

df_new.isnull().sum()

df_new.duplicated().sum()

df_new.describe()

df_new['RetailerCode'].value_counts().shape

df_new['DistributorCode_x'].value_counts()

df_new['DistributorCode_x'].value_counts().shape

distributor_counts = df_new['DistributorCode_x'].value_counts()   #try to understand 'DistributorCode_x'

plt.figure(figsize=(10, 6))
distributor_counts.plot(kind='bar')
plt.xlabel('Distributor Code')
plt.ylabel('Frequency')
plt.show()

category_counts = df_new['Category'].value_counts()         #try to understand 'Category'

plt.figure(figsize=(10, 8))
plt.pie(category_counts, labels=category_counts.index,  autopct='%d')
plt.axis('equal')
plt.show()

"""face wash, baby toiletries, hair care, persnal hygine products in demant"""

category_counts = df_new['SubCategory'].value_counts()       # #try to understand 'SubCategory'

plt.figure(figsize=(15, 10))
plt.pie(category_counts, labels=category_counts.index, autopct='%d')
plt.axis('equal')
plt.show()

plt.figure(figsize=(18, 6))                     #MRP distribution
sns.histplot(df_new['MRP'], kde=True)
plt.xlabel('MRP')
plt.ylabel('Density')
plt.grid(True)
plt.show()

"""normal price range between 0 to 400 rs product mostly sell"""

invoices_day = df_new.groupby(df_new['InvoiceDate'].dt.date).size()         # try to understand over time distribution of invoices

plt.figure(figsize=(15, 6))
invoices_day.plot()
plt.xlabel('Date')
plt.ylabel('Number of Invoices')
plt.show()

df_new['Discount'] = (df_new['MRP'] - df_new['Rate']) / df_new['MRP']*100  # featuring new column discount

df_new

from sklearn.preprocessing import LabelEncoder    #encode CategoryLabel column(using label encoding)

label_encoder = LabelEncoder()
df_new['CategoryLabel'] = label_encoder.fit_transform(df_new['Category'])
df_new.head()

df_new[['Category', 'CategoryLabel']].value_counts()



df_new["SubCategory"].value_counts()

label_encoder = LabelEncoder()                  #encode SubCategoryLabel column(using label encoding)

df_new['SubCategoryLabel'] = label_encoder.fit_transform(df_new['SubCategory'])

df_new

df_new[['SubCategory', 'SubCategoryLabel']].value_counts()

df_new.columns

df_new1=df_new.drop(columns=['Category', 'SubCategory'])

df_new1.columns

df_new1

"""apply linear regression for checking how model work on this data"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

X = df_new1[[   'MRP', 'Rate', 'NetAmount', 'Discount', 'CategoryLabel','SubCategoryLabel']]
y = df_new1['Quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
regressor = LinearRegression()
regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
print('Mean Squared Error:', mse)

r2 = r2_score(y_test, y_pred)
print('R-squared:', r2)

plt.scatter(y_test, y_pred)   # plot for better understandings

plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()])
plt.xlabel('Actual')
plt.ylabel('Predicted')



"""for better performance and previous results decide to remove outliers from features"""

plt.figure(figsize=(8, 6))
plt.boxplot(df['ProductCode'], vert=False)
plt.title("Outliers in ProductCode")
plt.xlabel("ProductCode")
plt.show()

columns_plot = ['MRP', 'Rate', 'NetAmount', 'Discount', 'CategoryLabel','SubCategoryLabel']

plt.figure(figsize=(12, 8))
for i, column in enumerate(columns_plot, 1):
    plt.subplot(3, 3, i)
    plt.hist(df_new1[column])
    plt.xlabel(column)
plt.tight_layout()
plt.show()

# df_new1= df_new1[df_new1['MRP'] <= 700]

# df_new1= df_new1[df_new1['Rate'] <= 600]

# for removing outliers using IQR method

columns_plot = ['MRP', 'Rate', 'NetAmount', 'Discount', 'CategoryLabel', 'SubCategoryLabel']

for column in columns_plot:
    Q1 = df_new1[column].quantile(0.25)
    Q3 = df_new1[column].quantile(0.75)
    IQR = Q3 - Q1

    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    df_new1 = df_new1[(df_new1[column] >= lower_bound) & (df_new1[column] <= upper_bound)]





columns_plot = ['MRP', 'Rate', 'NetAmount', 'Discount', 'CategoryLabel','SubCategoryLabel']

plt.figure(figsize=(12, 8))
for i, column in enumerate(columns_plot, 1):
    plt.subplot(3, 3, i)
    plt.hist(df_new1[column])
    plt.xlabel(column)
plt.tight_layout()
plt.show()

"""after remove outliers check model performanc"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

X = df_new1[['MRP','Rate', 'NetAmount', 'Discount', 'CategoryLabel','SubCategoryLabel']]
y = df_new1['Quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

regressor = LinearRegression()

regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
print('Mean Squared Error', mse)

r2 = r2_score(y_test, y_pred)
print('R-squared:', r2)

plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()])
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.show()

"""result is improved but for better results doing normalization of features"""

from sklearn.preprocessing import MinMaxScaler

columns_normalize = ['MRP', 'Rate', 'NetAmount', 'Discount']
scaler = MinMaxScaler()

df_new1[columns_normalize] = scaler.fit_transform(df_new1[columns_normalize])

df_new1

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

X = df_new1[['MRP', 'Rate', 'NetAmount', 'Discount','CategoryLabel','SubCategoryLabel']]
y = df_new1['Quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

regressor = LinearRegression()

regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
print('Mean Squared Error', mse)

r2 = r2_score(y_test, y_pred)
print('R-squared:', r2)

plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()])
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.show()

"""for better results apply Ridge, Lasso, ElasticNet and check results(overfitting, multicollinearity, and feature selection)"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import Ridge, Lasso, ElasticNet
from sklearn.metrics import mean_squared_error, r2_score

X = df_new1[['MRP', 'Rate', 'NetAmount', 'Discount', 'CategoryLabel', 'SubCategoryLabel']]
y = df_new1['Quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

ridge_regressor = Ridge(alpha=1.0)
ridge_regressor.fit(X_train, y_train)
y_pred_ridge = ridge_regressor.predict(X_test)
mse_ridge = mean_squared_error(y_test, y_pred_ridge)
r2_ridge = r2_score(y_test, y_pred_ridge)
print('Ridge Mean Squared Error:', mse_ridge)
print('Ridge R-squared:', r2_ridge)

lasso_regressor = Lasso(alpha=1.0)
lasso_regressor.fit(X_train, y_train)
y_pred_lasso = lasso_regressor.predict(X_test)
mse_lasso = mean_squared_error(y_test, y_pred_lasso)
r2_lasso = r2_score(y_test, y_pred_lasso)
print('Lasso Mean Squared Error:', mse_lasso)
print('Lasso R-squared:', r2_lasso)

elasticnet_regressor = ElasticNet(alpha=1.0, l1_ratio=0.5)
elasticnet_regressor.fit(X_train, y_train)
y_pred_elasticnet = elasticnet_regressor.predict(X_test)
mse_elasticnet = mean_squared_error(y_test, y_pred_elasticnet)
r2_elasticnet = r2_score(y_test, y_pred_elasticnet)
print('ElasticNet Mean Squared Error:', mse_elasticnet)
print('ElasticNet R-squared:', r2_elasticnet)

"""Ridge, Lasso, Elastic Net not give satisfying result so i change model and decide to apply random forest"""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

X = df_new1[['MRP', 'Rate', 'NetAmount', 'Discount','CategoryLabel','SubCategoryLabel']]
y = df_new1['Quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=50)
rf_regressor = RandomForestRegressor(n_estimators=30, random_state=42)
rf_regressor.fit(X_train, y_train)
y_pred = rf_regressor.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()])
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.show()

""" Random Forest give good result but same time overfit so i apply another one model XGboost"""

import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

X = df_new1[['MRP', 'Rate', 'NetAmount', 'Discount']]
y = df_new1['Quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
xgb_regressor = xgb.XGBRegressor(objective='reg:squarederror', random_state=42)
xgb_regressor.fit(X_train, y_train)

y_pred = xgb_regressor.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()])
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.show()

X_next_period = df_new1[['MRP', 'Rate', 'NetAmount', 'Discount']]

predicted_quantities = xgb_regressor.predict(X_next_period)

predicted_df = pd.DataFrame({'SubCategoryLabel': df_new1['SubCategoryLabel'], 'Predicted_Quantity': predicted_quantities})

predicted_df_sorted = predicted_df.sort_values(by='Predicted_Quantity', ascending=False)

top_10_items = predicted_df_sorted.head(10)

print(top_10_items)

df_new1['Category']  = df_new['Category']
df_new1['SubCategory'] = df_new['SubCategory']

df_new1.columns

"""i try to predict every distributer top 10 item to sell
for this use group by on distributer and apply regression on each distributer
"""

grouped_df = df_new.groupby('DistributorCode_x')
top_10_items_per_group = pd.DataFrame(columns=['DistributorCode_x', 'Item', 'Predicted_Quantity'])

for name, group in grouped_df:
    X_group = group[['MRP', 'Rate', 'NetAmount', 'Discount']]
    predicted_quantities_group = xgb_regressor.predict(X_group)
    predicted_df_group = pd.DataFrame({'SubCategory': group['SubCategory'], 'Predicted_Quantity': predicted_quantities_group})
    predicted_df_group_sorted = predicted_df_group.sort_values(by='Predicted_Quantity', ascending=False)

    top_10_items_group = predicted_df_group_sorted.head(10)
    top_10_items_group['DistributorCode_x'] = name
    top_10_items_per_group = top_10_items_per_group.append(top_10_items_group, ignore_index=True)

print("Top 10 items to distribute for each DistributorCode_x:")
print(top_10_items_per_group)

top_10_items_per_group

top_10_items_per_group.to_excel('/content/top_10_items.xlsx',index=False)

